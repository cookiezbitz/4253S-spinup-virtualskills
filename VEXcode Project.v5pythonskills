{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vrc import *\nfrom vexcode_vrc.events import get_Task_func\n  \n# constructors\n\ndrivetrain = Drivetrain()\nbrain = Brain()\nbottom_distance = Distance(\"BottomDistance\", 18)\nroller_optical = Optical(\"RollerOptical\", 2)\ngps = GPS(\"GPS\", 3)\nintake_motor_group = Motor(\"IntakeMotorGroup\", 10)\nbottom_line_tracker = LineTracker(\"BottomLineTracker\", 22)\nmiddle_line_tracker = LineTracker(\"MiddleLineTracker\", 23)\ntop_line_tracker = LineTracker(\"TopLineTracker\", 24)\n#endregion VEXcode Generated Robot Configuration\n\n# --------------------------------------------------\n# \n# \tProject:            VEXcode Project\n#\tAuthor:             VEX\n#\tCreated:            \n#\tDescription:        VEXcode V5 Python Project\n#   Starting Position:  \n#   Preload:            \n# \n# --------------------------------------------------\n\n#show all the sensors I used and explain what they do HERE\n#SPELL OUT THE RUBRIC\n#Sensors: top line tracker used to detect when \n\n\n#add a turn AND drive function to make my code more concise and understandable\n\n# Library imports\nfrom vexcode_vrc import *\n\n#function to turn roller\ndef turnroller():\n    intake_motor_group.set_velocity(80,PERCENT)\n    intake_motor_group.spin(REVERSE)\n    while not roller_optical.color() == RED.value:\n        wait(1, MSEC)\n    while not roller_optical.color() == BLUE.value:\n        wait(1, MSEC)\n    intake_motor_group.stop()\n\n#variables to fire the discs with\ndiscstoshoot = 0\ndiscsshot = 0\n\n#function to fire the disc\ndef shootdisc(discstoshoot):\n    intake_motor_group.spin(REVERSE)\n    for x in range(discstoshoot):\n        while not top_line_tracker.reflectivity(PERCENT) > 80:\n            wait(5, MSEC)\n          \n        while not top_line_tracker.reflectivity(PERCENT) < 20:\n            wait(5, MSEC)\n    discstoshoot = 0\n\n\n#function to position the robot to intake the disc\ndef movetodisc():\n    drivetrain.drive(FORWARD)\n    while not bottom_distance.object_distance(MM) < 20:\n        wait(5, MSEC)\n    drivetrain.stop()\n\n\n#to be used as a zig zagger to get discs near low goal barrier\ndiscstointake = 0\ndiscsintaked = 0\ndef intakedisc(discstointake):\n    discsintaked = 0\n    intake_motor_group.set_velocity(30,PERCENT)\n    intake_motor_group.spin(REVERSE)\n\n    while not bottom_line_tracker.reflectivity(PERCENT) > 80:\n            wait(5, MSEC)\n          \n    while not bottom_line_tracker.reflectivity(PERCENT) < 20:\n            wait(5, MSEC)\n    discsintaked += 1\n    while not discstointake == discsintaked:\n        wait(5,MSEC)\n\n\n    discstointake = 0\n    intake_motor_group.stop()\n#to be used as a zig zagger to get the discs near the low gal barrier\n\n\n#declaring the variables to be used in the drive to coordinate function\nendposx = 0\nendposy = 0\n\n#beginposx = 0\n#beginposy = 0\n#beginheading = 0\n\n\n#turnangle = 0\n#turnheading = 0\n#travelDistance = 0\n\nOtherturn = False\n\n#allows the robot to drive to anywhere on the field, given the desired end coordinate\ndef drivetocord(endposx,endposy, Otherturn):\n\n    #gets the values of the the robot's starting conditions when the function is called\n    #this includes the GPS x and y positions of the robot and the robot heading as read in the inertial sensor\n    beginposx = gps.x_position(MM)\n    beginposy = gps.y_position(MM)\n    beginheading = drivetrain.heading(DEGREES)\n\n\n    travelDistance = math.sqrt((endposx-(beginposx))**2 + (endposy-(beginposy))**2)\n\n    turnangle = (math.degrees(math.atan2((endposy-beginposy), (endposx - beginposx))))\n    \n    if Otherturn == False:\n        turnheading = beginheading - turnangle\n    else:\n        turnheading = 360 -( beginheading - turnangle +35 )\n    \n    \n    if turnheading > 360:\n        turnheading = turnheading -360\n        \n    if turnheading < 0:\n        turnheading = turnheading + 360\n\n    \"\"\"\n    brain.screen.print(turnangle)\n    brain.screen.next_row()\n    brain.screen.print(turnheading)\n    brain.screen.next_row()\n    brain.screen.print(beginposx)\n    brain.screen.next_row()\n    brain.screen.print(beginposy)\n    \"\"\"\n    \n    drivetrain.turn_to_heading(turnheading,DEGREES)\n    drivetrain.drive_for(FORWARD,travelDistance,MM)\n\n\n\n# Add project code in \"main\"\ndef main():\n\n\n\n\n    #SETUP CODE, GETS THE ROBOT TO BE AS FAST AS POSSIBLE\n    intake_motor_group.set_velocity(100,PERCENT)\n    drivetrain.set_drive_velocity(100,PERCENT)\n    drivetrain.set_turn_velocity(100,PERCENT)\n    drivetrain.set_heading(270,DEGREES)\n\n    #   FRONT of the bot is the intake\n    #   BACK of the bot is the shooter\n\n    #begin\n    drivetrain.drive_for(REVERSE,40,MM)\n    drivetrain.turn_to_heading(168,DEGREES)\n    drivetrain.drive_for(FORWARD,110,MM)\n\n    shootdisc(2)\n    #finishes section 1, shoots preloads\n    \n    intake_motor_group.spin(REVERSE)\n    #removable\n    drivetrain.drive_for(FORWARD,190,MM)\n\n    #removable\n\n\n\n    drivetrain.turn_to_heading(240,DEGREES)\n    drivetrain.drive_for(FORWARD,500,MM)\n    wait(.8,SECONDS)\n    intake_motor_group.stop()\n    drivetrain.turn_to_heading(192,DEGREES)\n    shootdisc(3)\n    #shoots 3 stack\n    intake_motor_group.spin(REVERSE)\n\n    drivetrain.turn_to_heading(270,DEGREES)\n    drivetrain.drive_for(FORWARD,640,MM)\n    wait(.1,SECONDS)\n    intake_motor_group.stop()\n    drivetrain.turn_to_heading(145,DEGREES)\n    intake_motor_group.set_velocity(50,PERCENT)\n    intake_motor_group.spin(REVERSE)\n    drivetrain.drive_for(FORWARD,210,MM)\n    #intakes 2 discs\n\n    intake_motor_group.set_velocity(90,PERCENT)\n    intake_motor_group.spin(REVERSE)\n    drivetrain.turn_to_heading(205,DEGREES)\n    shootdisc(2)\n    #shoots all two\n\n   \n    #turns towards the three stack\n    drivetrain.turn_to_heading(145,DEGREES)\n    intake_motor_group.set_velocity(90,PERCENT)\n    drivetrain.drive_for(FORWARD,390,MM)\n    wait(.8,SECONDS)\n    #intakes 3 stack\n\n    drivetrain.turn_to_heading(195,DEGREES)\n    shootdisc(3)\n    #fires 3 stack \n\n    #intakes the last two discs\n    drivetrain.turn_to_heading(135,DEGREES)\n    intake_motor_group.set_velocity(30,PERCENT)\n    drivetrain.drive_for(FORWARD,900,MM)\n    wait(.3,SECONDS)\n    drivetrain.turn_to_heading(178,DEGREES)\n    intake_motor_group.set_velocity(100,PERCENT)\n    shootdisc(2)\n    #fires last two discs\n\n\n    intake_motor_group.stop()\n\n    #positions bot in front of the roller\n    drivetrain.drive_for(REVERSE,200,MM)\n    drivetrain.turn_to_heading(270,DEGREES)\n    drivetrain.drive_for(REVERSE,110,MM)\n    #.1 turns is perfect for moving the roller once, but we could make use of the optical sensor here\n   \n    turnroller()\n   # intake_motor_group.spin_for(FORWARD,.1,TURNS)\n\n\n    #robot moves itself away from the roller to prepare to turn the other one\n    drivetrain.drive_for(FORWARD,500,MM)\n    drivetrain.turn_to_heading(0,DEGREES)\n    drivetrain.drive_for(REVERSE,297,MM)\n    #once again we can make use of the sensor\n    turnroller()\n\n    #resets the drivetrain heading to mitigate errors\n    #this can be a gps resetting point\n    drivetrain.set_heading(0,DEGREES)\n\n    #intakes 3 discs, the wait function here can be improved and the velocity can be perfected\n    drivetrain.turn_to_heading(308,DEGREES)\n    intake_motor_group.set_velocity(30,PERCENT)\n    intake_motor_group.spin(REVERSE)\n    drivetrain.drive_for(FORWARD,750,MM)\n    drivetrain.turn_to_heading(315,DEGREES)\n    drivetrain.drive_for(FORWARD,400,MM)\n    wait(.2,SECONDS)\n    drivetrain.drive_for(FORWARD,485,MM)\n    wait(.4,SECONDS)\n    #\n\n    #fires the discs\n    drivetrain.turn_to_heading(55,DEGREES)\n    intake_motor_group.set_velocity(100,PERCENT)\n    shootdisc(3)\n    #once again the wait can be perfected, or sensors can be used to detect when the last disc is fired\n\n    #manuevers the robot behind three discs for intaking\n    intake_motor_group.set_velocity(30,PERCENT)\n    drivetrain.turn_to_heading(180,DEGREES)\n    drivetrain.drive_for(FORWARD,800,MM)\n    drivetrain.turn_to_heading(225,DEGREES)\n    drivetrain.drive_for(FORWARD,300,MM)\n    wait(.2,SECONDS)\n    drivetrain.turn_to_heading(0,DEGREES)\n    drivetrain.drive_for(FORWARD,150,MM)\n    wait(.2,SECONDS)\n    drivetrain.drive_for(FORWARD,150,MM)\n    wait(.4,SECONDS)\n    drivetrain.drive_for(FORWARD,260,MM)\n    wait(.6,SECONDS)\n    #the robot occasionally misses discs here so the intake can be improved by rotating to where the disc should be every wait\n\n    drivetrain.turn_to_heading(55,DEGREES)\n    intake_motor_group.set_velocity(100,PERCENT)\n    shootdisc(3)\n\n\n    #drivetocord(300,300,True)\n    drivetrain.turn_to_heading(0,DEGREES)\n    drivetrain.drive_for(FORWARD,400,MM)\n    drivetrain.turn_to_heading(270,DEGREES)\n    intake_motor_group.set_velocity(30,PERCENT)\n    drivetrain.drive_for(FORWARD,200,MM)\n    wait(.3,SECONDS)\n    drivetrain.drive_for(FORWARD,130,MM)\n    wait(.3,SECONDS)\n    drivetrain.drive_for(FORWARD,220,MM)\n    wait(.5,SECONDS)\n    drivetrain.turn_to_heading(24,DEGREES)\n    intake_motor_group.set_velocity(100,PERCENT)\n    shootdisc(3)\n    \n\n\n\n    #fires the discs\n    drivetrain.drive_for(FORWARD,100,MM)\n    drivetocord(1500,220, True)\n\n\n\n\n\n    intake_motor_group.set_velocity(100,PERCENT)\n    drivetrain.turn_to_heading(347,DEGREES)\n    #troubleshoot code\n    brain.screen.next_row()\n    brain.screen.next_row()\n    brain.screen.print(gps.x_position(MM))\n    brain.screen.next_row()\n    brain.screen.print(gps.y_position(MM))\n\n    shootdisc(1)\n    wait(20,SECONDS)\n    #fires the blue side match loads\n    \n    drivetrain.turn_to_heading(45,DEGREES)\n    drivetrain.drive_for(FORWARD,550,MM)\n    intake_motor_group.set_velocity(55,PERCENT)\n    wait(1,SECONDS)\n    drivetrain.turn_to_heading(5,DEGREES)\n    intake_motor_group.set_velocity(100,PERCENT)\n    drivetrain.drive_for(FORWARD,100,MM,wait=False)\n    shootdisc(3)\n    drivetrain.turn_to_heading(90,DEGREES)\n    intake_motor_group.set_velocity(30,PERCENT)\n    drivetrain.drive_for(FORWARD,750,MM)\n    drivetrain.turn_to_heading(315,DEGREES)\n    drivetrain.drive_for(FORWARD,350,MM)\n    drivetrain.turn_to_heading(23,DEGREES)\n    intake_motor_group.set_velocity(90,PERCENT)\n    shootdisc(2)\n    intake_motor_group.spin(REVERSE)\n    intake_motor_group.set_velocity(50,PERCENT)\n    drivetrain.turn_to_heading(315,DEGREES)\n    drivetrain.drive_for(FORWARD,350,MM)\n    wait(1.2,SECONDS)\n    drivetrain.turn_to_heading(13,DEGREES)\n    intake_motor_group.set_velocity(94,PERCENT)\n    shootdisc(3)\n    drivetrain.turn_to_heading(315,DEGREES)\n    intake_motor_group.set_velocity(30,PERCENT)\n    drivetrain.drive_for(FORWARD,350,MM)\n    wait(.2,SECONDS)\n    drivetrain.drive_for(FORWARD,450,MM)\n    wait(.2,SECONDS)\n    drivetrain.turn_to_heading(359,DEGREES)\n    intake_motor_group.set_velocity(100,PERCENT)\n    shootdisc(2)\n    \n\n    \n\n\n    \n\n\n\n\n    \"\"\"\n    drivetrain.turn_to_heading(21,DEGREES)\n    intake_motor_group.set_velocity(100,PERCENT)\n    wait(2,SECONDS)\n    \n    drivetrain.turn_to_heading(0,DEGREES)\n    drivetrain.drive_for(FORWARD,550,MM)\n    wait(.5,SECONDS)\n    drivetrain.turn_to_heading(17,DEGREES)\n    wait(2,SECONDS)\n    drivetrain.turn_to_heading(0,DEGREES)\n    drivetrain.drive_for(FORWARD,600,MM)\n    intake_motor_group.set_velocity(95,PERCENT)\n    drivetrain.turn_to_heading(10,DEGREES)\n    wait(2,SECONDS)\n    drivetrain.turn_to_heading(0,DEGREES)\n    drivetrain.drive_for(REVERSE,990,MM)\n    drivetrain.turn_to_heading(90,DEGREES)\n    drivetrain.drive_for(REVERSE,575,MM)\n    drivetrain.turn_to_heading(349,DEGREES)\n    drivetrain.drive_for(FORWARD,90,MM)\n\n\"\"\"\n    \n\n\n    \n\n   \n\n\n\n    \"\"\"\n    continuemoving = True\n\n    #troublehsooting code\n    #print(top_line_tracker.reflectivity(PERCENT))\n\n    #console prints to brain screen, need to include brain screen when printing\n\n\n\n    #moves the robot into position to fire the discs into high goal\n    drivetrain.drive_for(FORWARD, 200, MM)\n    drivetrain.turn_to_heading(180,DEGREES)\n\n    #fires the discs into the high goal\n    intake_motor_group.spin(REVERSE)\n    wait(1,SECONDS)\n    #stopping the motor is necesary in order to prevent an error (loop)\n    intake_motor_group.stop()\n\n    #drives the robot into position to take in the match loads\n    drivetrain.drive_for(FORWARD,300,MM)\n    drivetrain.turn_to_heading(90,DEGREES)\n\n    #intakes the match loads\n    intake_motor_group.spin(REVERSE)\n    drivetrain.drive_for(FORWARD,230,MM)\n\n    #the wait function allows for the discs time to make their way up\n    wait(.85,SECONDS)\n    intake_motor_group.stop()\n\n    #positions the robot to prepare to fire the match loads\n    drivetrain.drive_for(REVERSE,120,MM)\n    #changing the position here allows for more discs to be able to be shot into the goal\n    drivetrain.turn_to_heading(180,DEGREES)\n    intake_motor_group.set_velocity(100,PERCENT)\n    #fires the match load\n    intake_motor_group.spin(REVERSE)\n    #wait function provides time for all discs to fly into goal\n    wait(2,SECONDS)\n    intake_motor_group.stop()\n        #repositions the bot after firing\n    drivetrain.turn_to_heading(90,DEGREES)\n    drivetrain.drive_for(FORWARD,120,MM)\n    drivetrain.drive_for(REVERSE,300,MM)\n    #bot repositioned, preparing to intake discs\n    wait(1,SECONDS)\n    intake_motor_group.set_velocity(100,PERCENT)\n    intake_motor_group.spin(REVERSE)\n    drivetrain.drive_for(FORWARD,300,MM)\n\n    wait(.85,SECONDS)\n    intake_motor_group.stop()\n    drivetrain.turn_to_heading(180,DEGREES)\n    intake_motor_group.set_velocity(100,PERCENT)\n    intake_motor_group.spin(REVERSE)\n    wait(2,SECONDS)\n    intake_motor_group.stop()\n    drivetrain.drive_for(FORWARD,1200,MM)\n    drivetrain.turn_to_heading(270,DEGREES)\n    drivetrain.drive_for(REVERSE,30,MM)\n    intake_motor_group.spin_for(FORWARD,.1,TURNS)\n    drivetrain.drive_for(FORWARD,480,MM)\n    drivetrain.turn_to_heading(0,DEGREES)\n    drivetrain.drive_for(REVERSE,280,MM)\n    intake_motor_group.spin_for(FORWARD,.1,TURNS)\n\n\n    # first part 60 points in 13 seconds, always misses the first disc. code CAN be made more efficient\n    # again this CAN BE MADE MORE EFFICIENT WITH WORK\n\n    \"\"\"\n    \"\"\"\n    drivetrain.drive_for(FORWARD, 1200, MM)\n    drivetrain.turn_to_heading(270,DEGREES)\n\n\n    drivetrain.set_drive_velocity(30,PERCENT)\n    intake_motor_group.set_velocity(30,PERCENT)\n\n\n    #part below is prone to not working, i got too stressed, getting rid of it\n    \"\"\"\n    \"\"\"\n    while continuemoving == True:\n      while top_line_tracker.reflectivity(PERCENT) == 84:\n         \n         intake_motor_group.stop()\n         continuemoving = False\n      else:\n         drivetrain.drive(FORWARD)\n         intake_motor_group.spin(REVERSE)\n         #troubleshooting code below\n         i = 0\n         while i<30:\n              brain.screen.print(top_line_tracker.reflectivity(PERCENT))\n              brain.screen.next_row()\n              i = i+ 1\n              if middle_line_tracker.reflectivity(PERCENT) == 84:\n                continuemoving = False\n\n\n\n\n    intake_motor_group.stop()\n    wait(300,SECONDS);\n    \"\"\"\n\n    \n\n    \n# VR threads — Do not delete\nvr_thread(main)\n","textLanguage":"python","rconfig":[],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"2.4.0","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Virtual","virtualSkillsYear":"2023"}
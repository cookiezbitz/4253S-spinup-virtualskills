{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vrc import *\nfrom vexcode_vrc.events import get_Task_func\n  \n# constructors\n\ndrivetrain = Drivetrain()\nbrain = Brain()\nbottom_distance = Distance(\"BottomDistance\", 18)\nroller_optical = Optical(\"RollerOptical\", 2)\ngps = GPS(\"GPS\", 3)\nintake_motor_group = Motor(\"IntakeMotorGroup\", 10)\nbottom_line_tracker = LineTracker(\"BottomLineTracker\", 22)\nmiddle_line_tracker = LineTracker(\"MiddleLineTracker\", 23)\ntop_line_tracker = LineTracker(\"TopLineTracker\", 24)\n#endregion VEXcode Generated Robot Configuration\n\n# --------------------------------------------------\n# \n# \tProject:            VEXcode Project\n#\tAuthor:             VEX\n#\tCreated:            \n#\tDescription:        VEXcode V5 Python Project\n#   Starting Position:  \n#   Preload:            \n# \n# --------------------------------------------------\n\n#show all the sensors I used and explain what they do HERE\n#SPELL OUT THE RUBRIC\n#Sensors: top line tracker used to detect when \n\n\n#add a turn AND drive function to make my code more concise and understandable\n#ALL DISTENCE UNITS IN MILLIMETERS; ALL ANGLE UNITS IN DEGREES\n\n# Library imports\nfrom vexcode_vrc import *\n\n\n#This is a setup function that will be ran once in the beginning of the code\ndef codesetup():\n    intake_motor_group.set_velocity(100,PERCENT)\n    drivetrain.set_drive_velocity(100,PERCENT)\n    drivetrain.set_turn_velocity(100,PERCENT)\n    drivetrain.set_heading(270,DEGREES)\n\n\n\n#function to turn roller\n#uses the optical sensor and while loop conditionals\ndef turnroller():\n    intake_motor_group.set_velocity(80,PERCENT)\n    intake_motor_group.spin(REVERSE)\n    while not roller_optical.color() == RED.value:\n        wait(1, MSEC)\n    #detects weather or not the roller is red\n    while not roller_optical.color() == BLUE.value:\n        wait(1, MSEC)\n    #detects weather or not the roller is blue\n    intake_motor_group.stop()\n    #if the optical sensor detects that the roller has been turned to the red side, the intake stops\n    \n\n\n\n#variables used in the shoot disc function\ndiscstoshoot = 0\n#this variable is assigned every time the function is called, it tells the function how many discs it needs to shoot\n\n#function to fire the disc\n#uses the line sensor, while loops, and for loop conditionals\ndef shootdisc(discstoshoot):\n    intake_motor_group.spin(REVERSE)\n    for x in range(discstoshoot):\n    #for loop repeats this sequence depending on the numerical value assigned in the \"discstoshoot\" variable\n        while not top_line_tracker.reflectivity(PERCENT) > 80:\n            wait(5, MSEC)\n        #This conditional detects weather or not the disc is at the top of the intake using the line tracker sensor\n        #If it is, then the program moves on to the next line\n        while not top_line_tracker.reflectivity(PERCENT) < 20:\n            wait(5, MSEC)\n        #This conditional allows for the disc to fire: the intake will spin until the sensor is no longer detecting the disc\n        #after the sensor detects that the disc is no longer there,\n        #it will acknowldge that it has shot 1/discstoshoot and will repeat until it has shot all of the discs\n\n\n\n#function to position the robot in front of a disc\n# uses the optical sensor and while loop conditionals\ndef movetodisc():\n    drivetrain.drive(FORWARD)\n    while not bottom_distance.object_distance(MM) < 20:\n        wait(5, MSEC)\n    drivetrain.stop()\n\n\n\n\n#variables used in the intake disc function\nstack = True\n#the variable is assigned by the user, it tells the function whether or not the discs it is intaking is in a stack or not\n#True denotes, yes, it is in a stack, while False means no stack\ndiscstointake = 0\n#This variable is also assigned by the user. It tells the function the amount of discs it needs to intake\n\n\n#function to intake discs\n#uses line and distence sensors, also uses while and for loop conditionals\ndef intakedisc(discstointake, stack):\n    if stack == True:\n    #checks if the discs are in a stack\n        while bottom_distance.object_distance(MM) < 40:\n        #checks if the discs are within 40 millimeters of the intake\n            intake_motor_group.spin(REVERSE)\n            #turns the roller in the Intake direction\n            wait(5, MSEC)\n        while not top_line_tracker.reflectivity(PERCENT)>80:\n        #checks if the disc is at the top of the intake\n            wait(5,MSEC)\n        intake_motor_group.stop()\n        #if the disc is at the top of the intake, the process is complete and \n    else:\n    #this part runs if the disc is not a stack\n        for x in range(discstointake):\n        #the loop repeats for every disc that needs to be intaked\n            movetodisc()\n            #the robot moves to the disc\n            while bottom_distance.object_distance(MM) < 40:\n            #if the robot is less than 40 millimeters away from the disc, it is able to intake it\n                intake_motor_group.spin(REVERSE)\n                #the robot intakes that disc and the for loop repeats for every disc needed\n                wait(5, MSEC)\n\n\n\n\n#declaring the variables to be used in the drive to coordinate function\nendposx = 0\nendposy = 0\n#end posy and x denote the coordinate that the function tells the robot to move to\n#variables assigned by user\n\nbeginposx = 0\nbeginposy = 0\nbeginheading = 0\n#These starting conditions collect info from the GPS sensor\n#has the beginning coordinate position and orientation\n\n\nturnangle = 0\nturnheading = 0\ntravelDistance = 0\n#These values are all CALCULATED by the function using trigonometric equations\n\nOtherturn = False\n#this boolean is assigned by the user to change how the robot can move in this function\n\n#allows the robot to drive to anywhere on the field, given the desired end coordinate\ndef drivetocord(endposx,endposy, Otherturn):\n#drive to coordinate function collects the desired endpoint and whether or not otherturn will be used\n\n\n    beginposx = gps.x_position(MM)\n    beginposy = gps.y_position(MM)\n    beginheading = drivetrain.heading(DEGREES)\n    #gets the values of the the robot's starting conditions when the function is called\n    #this includes the GPS x and y positions of the robot and the robot heading as read in the inertial sensor\n\n\n    travelDistance = math.sqrt((endposx-(beginposx))**2 + (endposy-(beginposy))**2)\n    #calculates for travel distance using the pythagorean theorem\n\n    turnangle = (math.degrees(math.atan2((endposy-beginposy), (endposx - beginposx))))\n    #calculates the tangent using trigonometric functions\n    #the tangent is the angle that the robot needs to turn to face the end position coordinate\n    \n    if Otherturn == False:\n        turnheading = beginheading - turnangle\n        #if the  otherturn boolean is not needed, then the turn headding is calculated normally\n    else:\n        turnheading = 360 -( beginheading - turnangle +35 )\n        #if the otherturn boolean is needed, then it will make adjustments to the robot's turn so it remains accurate\n\n    #To find out if otherturn is needed, it should be tested in the program\n    \n    #Headings go from 0-360\n    #these corrections make if the turnheading goes over or under the range\n    if turnheading > 360:\n        turnheading = turnheading -360\n        \n    if turnheading < 0:\n        turnheading = turnheading + 360\n\n    \"\"\"\n    brain.screen.print(turnangle)\n    brain.screen.next_row()\n    brain.screen.print(turnheading)\n    brain.screen.next_row()\n    brain.screen.print(beginposx)\n    brain.screen.next_row()\n    brain.screen.print(beginposy)\n    \"\"\"\n    \n    #The robot turns to the calculated heading using the inertial sensor\n    drivetrain.turn_to_heading(turnheading,DEGREES)\n    #the robot travels the calculated distence\n    drivetrain.drive_for(FORWARD,travelDistance,MM)\n    \n\n\n# Add project code in \"main\"\ndef main():\n\n\n    codesetup()\n\n    #SETUP CODE, GETS THE ROBOT TO BE AS FAST AS POSSIBLE\n\n\n    #   FRONT of the bot is the intake\n    #   BACK of the bot is the shooter\n\n\n\n\n\n    #AUTONOMOUS BEGIN\n    drivetrain.drive_for(REVERSE,40,MM)\n    drivetrain.turn_to_heading(168,DEGREES)\n    drivetrain.drive_for(FORWARD,110,MM)\n    #Robot positions itself so it's intake faces the match loader and the shooter faces the high goal\n    #this allows for the robot to intake and shoot at the same time\n    shootdisc(9)\n    #the robot shoots 9 discs, including the 2 preloads and 7 match loads\n    drivetrain.drive_for(FORWARD,190,MM)\n    #robot repositions itself so it can intake a stack of 3 discs\n\n\n    #Spinning the intake in REVERSE allows for the discs to be brought IN to the robot and for the disc to be shot out,\n    #while spinning the intake in FORWARD brings the discs OUT \n\n    drivetrain.turn_to_heading(240,DEGREES)\n    drivetrain.drive_for(FORWARD,500,MM)\n    intakedisc(3,True)\n    #intakedisc() collects the parameters of how many discs you would like to intake, and weather or not the discs are a stack.\n    drivetrain.turn_to_heading(192,DEGREES)\n    #the robot's shooter turns to face towards the high goal.\n    #it is necesary to include specific degrees like 192 to ensure that the discs being shot here do not interfere (knock out) the discs that have been previously shot\n    #192 degrees is angled in a way where it will not knock out other discs\n    shootdisc(3)\n    #shoots 3 stack\n\n    #the robot prepares to intake two discs\n    drivetrain.turn_to_heading(270,DEGREES)\n    drivetrain.drive_for(FORWARD,640,MM)\n    wait(.1,SECONDS)\n    #the robot drives into range for intaking the disc\n    #since the intake is already spinning, it waits .1 of a second for the disc to be held by the robot\n    intake_motor_group.set_velocity(86,PERCENT)\n    #the velocity is set lower so the disc does not get shot out early and miss the goal\n    drivetrain.turn_to_heading(145,DEGREES)\n    #drivetrain turns to intake another disc\n    drivetrain.drive_for(FORWARD,210,MM)\n    #drivetrain drives into disc, no extra wait time is needed\n\n    intake_motor_group.set_velocity(96,PERCENT)\n    #velocity goes as high as accurately possible\n\n    drivetrain.turn_to_heading(205,DEGREES,wait=False)\n    #the drivetrain turns so shooter faces the goal\n    #the boolean at the end of the function tells the next line to move on before the drivetrain has finished turning\n    shootdisc(2)\n    #shoots all two discs\n\n   \n    intake_motor_group.set_velocity(96,PERCENT)\n    #reset the intake motor velocity to 100\n    drivetrain.turn_to_heading(145,DEGREES)\n    #turns towards the three stack\n    drivetrain.drive_for(FORWARD,390,MM)\n    intakedisc(3,True)\n    #drives to and intakes 3 stack\n\n    drivetrain.turn_to_heading(195,DEGREES)\n    #drivetrain turns towards high goal\n    shootdisc(3)\n    #fires 3 stack \n\n    drivetrain.turn_to_heading(135,DEGREES)\n    #turns to intake two discs\n    intake_motor_group.set_velocity(86,PERCENT)\n    drivetrain.drive_for(FORWARD,900,MM)\n    #drives into the first disc, which it intakes while the robot moves\n    wait(.1,SECONDS)\n    #waits .1 seconds for the second disc to be held by the robot\n    drivetrain.turn_to_heading(178,DEGREES)\n    #the robot's shooter turns to face the blue high goal\n    intake_motor_group.set_velocity(100,PERCENT)\n    shootdisc(2)\n    #fires two discs\n\n\n    intake_motor_group.stop()\n    #intake stops to not interfere with the roller turning functions\n\n    #positions bot in front of the roller\n    drivetrain.drive_for(REVERSE,200,MM)\n    drivetrain.turn_to_heading(270,DEGREES)\n    #turns so that the robot's rolling mech is facing the roller\n    drivetrain.drive_for(REVERSE,110,MM)\n\n\n    turnroller()\n    #uses the optical sensor to detect how much the roller needs to be turned, and turns the roller accordingly\n\n\n    #Robot moves to the second roller\n    drivetrain.drive_for(FORWARD,500,MM)\n    drivetrain.turn_to_heading(0,DEGREES)\n    #turns so that the robot's rolling mech is facing the roller\n    drivetrain.drive_for(REVERSE,297,MM)\n    turnroller()\n    #robot uses the optical sensor again to turn the roller\n\n    #resets the drivetrain heading to mitigate potential future errors\n    drivetrain.set_heading(0,DEGREES)\n\n\n    drivetrain.turn_to_heading(308,DEGREES)\n    #alligns the intake with the first disc\n\n    intake_motor_group.set_velocity(45,PERCENT)\n    intake_motor_group.spin(REVERSE)\n    #activates the intake for the three discs\n\n    drivetrain.drive_for(FORWARD,750,MM)\n    #drives into the first of the three discs, intakes it\n    drivetrain.turn_to_heading(315,DEGREES)\n    #realigns the drivetrain for the next to discs\n\n    drivetrain.drive_for(FORWARD,885,MM)\n    #drives to the third of the three discs. picks up the second disc along the way\n    wait(.15,SECONDS)\n    #wait gives the robot time to intake the discs\n    \n\n\n    drivetrain.turn_to_heading(45,DEGREES)\n    intake_motor_group.set_velocity(100,PERCENT)\n    #aims the shooter at the RED HIGH GOAL\n    shootdisc(3)\n    #fires the three discs\n\n    #manuevers the robot behind three discs for intaking\n    intake_motor_group.set_velocity(45,PERCENT)\n    drivetrain.turn_to_heading(180,DEGREES)\n    drivetrain.drive_for(FORWARD,800,MM)\n    drivetrain.turn_to_heading(225,DEGREES)\n\n\n    #The following is a sequence that is uniquely usedd when collecting discs near barriers\n    #In this sequence, the robot staggers its movement by having short pauses inbetween to intake the iscs\n\n    drivetrain.drive_for(FORWARD,300,MM)\n    wait(.1,SECONDS)\n    drivetrain.turn_to_heading(0,DEGREES)\n    drivetrain.drive_for(FORWARD,150,MM)\n    wait(.1,SECONDS)\n    drivetrain.drive_for(FORWARD,150,MM)\n    wait(.2,SECONDS)\n    drivetrain.drive_for(FORWARD,260,MM)\n    wait(.4,SECONDS)\n\n    \n    \n    drivetrain.turn_to_heading(55,DEGREES)\n    #after collecting the discs, the robot aims towards the RED GOAL\n    intake_motor_group.set_velocity(100,PERCENT)\n    shootdisc(3)\n    #the bot fires all three discs into the goal\n\n\n    #The bot the  repositions itself to intake three more barrier goals\n    drivetrain.turn_to_heading(0,DEGREES)\n    drivetrain.drive_for(FORWARD,400,MM)\n    drivetrain.turn_to_heading(270,DEGREES)\n\n    #the bot intakes the discs by driving over the barrier goals\n    #once again, it uses a staggering driving sequence as before\n    intake_motor_group.set_velocity(40,PERCENT)\n    drivetrain.drive_for(FORWARD,200,MM)\n    wait(.1,SECONDS)\n    drivetrain.drive_for(FORWARD,130,MM)\n    wait(.2,SECONDS)\n    drivetrain.drive_for(FORWARD,220,MM)\n    wait(.5,SECONDS)\n\n    #turns towards the RED HIGH GOAL to shoot the disc\n    drivetrain.turn_to_heading(24,DEGREES)\n    intake_motor_group.set_velocity(100,PERCENT)\n    shootdisc(3)\n    #shoots the three discs\n    \n    #The robot drives to this coordinate as a sort of \"Position resetting point\"\n    #this is to correct the positional errors that might have arisen from driving over barriers\n    drivetrain.drive_for(FORWARD,100,MM)\n    drivetocord(1500,220, True)\n    #the coordinates the robot drives to puts it in position to intake from the match loader\n    #the robot can also shoot into the red high goal from this position\n\n    intake_motor_group.set_velocity(100,PERCENT)\n    drivetrain.turn_to_heading(347,DEGREES)\n    #the robot turns to aim at the shooter\n\n    shootdisc(7)\n    #shoots 7 match loads\n    \n    drivetrain.turn_to_heading(45,DEGREES)\n    drivetrain.drive_for(FORWARD,550,MM)\n    #robot turns and drives to a stack of 3 discs\n    intake_motor_group.set_velocity(55,PERCENT)\n    intakedisc(3,True)\n    #intakes the stack of 3\n\n    #prepares to shoot the stack of 3 discs\n    drivetrain.turn_to_heading(12,DEGREES)\n    #Robot turns to aim it's shooter at the red high goal\n    intake_motor_group.set_velocity(100,PERCENT)\n    drivetrain.drive_for(FORWARD,100,MM,wait=False)\n    shootdisc(3)\n    #robot fires three discs\n    wait(.45,SECONDS)\n    #allows the robot to have time to recalibrate before moving on\n\n    #turns to the disc at the top of the autonomous line and turns to have the intake face it\n    drivetrain.turn_to_heading(90,DEGREES)\n    intake_motor_group.set_velocity(50,PERCENT)\n    drivetrain.drive_for(FORWARD,750,MM)\n    #drives over to the disc\n    drivetrain.turn_to_heading(315,DEGREES)\n    #the disc is intaked while it turns to face another colinear disc on the autonomous line\n\n    drivetrain.drive_for(FORWARD,350,MM)\n    drivetrain.turn_to_heading(23,DEGREES)\n    #The robot drives to and intakes the second disc as it turns\n\n    intake_motor_group.set_velocity(96,PERCENT)\n    shootdisc(2)\n    #with all the discs intaked, the robot shoots two discs into the red high goal\n\n    intake_motor_group.set_velocity(100,PERCENT)\n    drivetrain.turn_to_heading(315,DEGREES)\n    drivetrain.drive_for(FORWARD,350,MM)\n    #the robot positions it's intake in front of the 3 stack of discs\n    intakedisc(3,True)\n    #the robot shoots the disc then prepares to fire by aiming it's shooter at the red high goal\n    drivetrain.turn_to_heading(13,DEGREES)\n    intake_motor_group.set_velocity(94,PERCENT)\n    shootdisc(3)\n    #The robot shoots all three discs\n\n    #The robot turns to face the last two discs on the autonomous line\n    drivetrain.turn_to_heading(315,DEGREES)\n    intake_motor_group.set_velocity(50,PERCENT)\n    drivetrain.drive_for(FORWARD,850,MM)\n    wait(.1,SECONDS)\n    #the robot intakes the two discs, collecting one while it drives \n\n    drivetrain.turn_to_heading(359,DEGREES)\n    #robot aims it's shooter towards the red goal\n    intake_motor_group.set_velocity(96,PERCENT)\n    drivetrain.drive_for(REVERSE,150,MM,wait=False)\n    shootdisc(2)\n    #robot fires the two discs into the red goal, the robot also moves to line itself up with the roller at the same time'\n\n\n    drivetrain.turn_to_heading(90,DEGREES)\n    #robot turns so it's roller mech is facing the other roller\n    drivetrain.drive_for(REVERSE,100,MM)\n    turnroller()\n    #the robot turns the roller to RED\n\n    #repositions to prepare to turn the other roller\n    drivetrain.drive_for(FORWARD,500,MM)\n    drivetrain.turn_to_heading(180,DEGREES)\n    drivetrain.drive_for(REVERSE,265,MM)\n    turnroller()\n   #turns the roller to RED once it is in range \n\n    #Prepares to intake the line of three discs\n    intake_motor_group.set_velocity(40,PERCENT)\n    intake_motor_group.spin(REVERSE)\n\n    drivetrain.turn_to_heading(130,DEGREES)\n    #turns so that the intake is facing towards the first of three discs\n    drivetrain.drive_for(FORWARD,700,MM)\n    wait(.1,SECONDS)\n    #Drives to the first disc and intakes it\n    drivetrain.turn_to_heading(135,DEGREES)\n    #turns to the other two discs in the line\n    drivetrain.drive_for(FORWARD,870,MM)\n    wait(.3,SECONDS)\n    drivetrain.drive_for(FORWARD,500,MM)\n    #intakes the 2nd and third disc as it moves down the line\n    drivetrain.turn_to_heading(215,DEGREES)\n    #turns to face the BLUE GOAL\n    intake_motor_group.set_velocity(96,PERCENT)\n    shootdisc(3)\n    #Fires the three discs into the blue goal\n    #drivetrain.drive_for(FORWARD,400,MM)\n\n\n    \n\n    \n# VR threads — Do not delete\nvr_thread(main)\n","textLanguage":"python","rconfig":[],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"2.4.0","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Virtual","virtualSkillsYear":"2023"}